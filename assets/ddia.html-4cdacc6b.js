import{_ as h,r as d,o as l,c as n,a as e,b as a,d as t,e as r}from"./app-097a6a1b.js";const o={},s=r('<h1 id="设计数据密集型应用" tabindex="-1"><a class="header-anchor" href="#设计数据密集型应用" aria-hidden="true">#</a> 设计数据密集型应用</h1><p>其实关于这种神书，是需要反复阅读多遍的</p><h2 id="第一章-可靠性、可伸缩性和可维护性" tabindex="-1"><a class="header-anchor" href="#第一章-可靠性、可伸缩性和可维护性" aria-hidden="true">#</a> 第一章 可靠性、可伸缩性和可维护性</h2><h3 id="关于推特设计的例子" tabindex="-1"><a class="header-anchor" href="#关于推特设计的例子" aria-hidden="true">#</a> 关于推特设计的例子</h3>',4),c={href:"http://ddia.vonng.com/#/ch1",target:"_blank",rel:"noopener noreferrer"},p=e("br",null,null,-1),u=r('<h2 id="第三章-存储和检索" tabindex="-1"><a class="header-anchor" href="#第三章-存储和检索" aria-hidden="true">#</a> 第三章 存储和检索</h2><p>两大类存储引擎，日志结构(log-structured)的存储引擎,面向页面（page-oriented）的存储引擎(例如B树) 日志结构学派：只允许追加到文件和删除过时的文件，但不会更新已经写入的文件。Bitcask、SSTables、LSM 树、LevelDB、Cassandra、HBase、Lucene 等都属于这个类别。 就地更新学派：将硬盘视为一组可以覆写的固定大小的页面。 B 树是这种理念的典范，用在所有主要的关系数据库和许多非关系型数据库中。</p><h2 id="一些值得反复品味的话" tabindex="-1"><a class="header-anchor" href="#一些值得反复品味的话" aria-hidden="true">#</a> 一些值得反复品味的话</h2><blockquote><p>消除额外复杂度的最好工具之一是抽象 高级编程语言是一种抽象，隐藏了机器码、CPU 寄存器和系统调用.SQL也是一种抽象，隐藏了复杂的磁盘/内存数据结构、来自其他客户端的并发请求、崩溃后的不一致性 确实整个计算机世界中无处不存在着抽象</p></blockquote><h3 id="关于b树与lsm树的一些比较" tabindex="-1"><a class="header-anchor" href="#关于b树与lsm树的一些比较" aria-hidden="true">#</a> 关于B树与LSM树的一些比较</h3><p>根据经验，通常LSM树的写入更快，而B树的读取速度更快，LSM树上的读取速度通常比较慢，因为他们必须检查几种不同的数据结构和不同压缩层级的 SSTables</p><h3 id="一些优化的细节" tabindex="-1"><a class="header-anchor" href="#一些优化的细节" aria-hidden="true">#</a> 一些优化的细节</h3><p>要让存储引擎再实践中表现良好涉及到大量的技术细节。</p><ol><li>查找数据库中不存在的键时，LSM树算法可能会很慢；你必须先检查内存表，然后查看最近的到最旧的所有的段（可能还必须从硬盘去读取每一个段文件），才能确认这个键是否存在。为了访问这种优化，存储引擎通常使用额外的布隆过滤器</li></ol><h2 id="关于分布式数据" tabindex="-1"><a class="header-anchor" href="#关于分布式数据" aria-hidden="true">#</a> 关于分布式数据</h2><p>需要考虑的三个点：</p><ol><li>可伸缩性 如果你的数据量、读取负载、写入负载超出单台机器的处理能力，可以将负载分散到多台计算机上</li><li>容错/高可用性 需要在单台机器（或多台机器，网络或整个数据中心）出现故障的情况下仍然能继续工作</li><li>延迟 如果世界各地都有用户，可以考虑多地域多机房</li></ol><h2 id="第五章-复制" tabindex="-1"><a class="header-anchor" href="#第五章-复制" aria-hidden="true">#</a> 第五章 复制</h2><h3 id="多主复制" tabindex="-1"><a class="header-anchor" href="#多主复制" aria-hidden="true">#</a> 多主复制</h3><p>自定义冲突解决逻辑：</p><ol><li>写时执行</li><li>读时执行</li></ol><h3 id="无主复制" tabindex="-1"><a class="header-anchor" href="#无主复制" aria-hidden="true">#</a> 无主复制</h3><p>单主复制与多主复制</p><h2 id="第六章" tabindex="-1"><a class="header-anchor" href="#第六章" aria-hidden="true">#</a> 第六章</h2><p>关于分区的问题，其实最容易遇到的就是热点的问题，不论是单key热点，还是单分片热点，或者说单key热点本身其实也就是单分片热点 可以在业务上去更好地将热点打散</p><h3 id="再平衡策略" tabindex="-1"><a class="header-anchor" href="#再平衡策略" aria-hidden="true">#</a> 再平衡策略</h3><ol><li></li></ol><h2 id="第七章-事务" tabindex="-1"><a class="header-anchor" href="#第七章-事务" aria-hidden="true">#</a> 第七章 事务</h2><p>两阶段锁定 2PL 和 两阶段提交 2PC的区别</p><h2 id="一些疑惑" tabindex="-1"><a class="header-anchor" href="#一些疑惑" aria-hidden="true">#</a> 一些疑惑</h2><ol><li><p>压缩的时候，如果有数据写入或者读取怎么办 我的想法，如果是有数据写入，就写到新的段里面，有读取的话，旧的段也是可以读的</p></li><li><p>关于Lucene中用的类似于SSTable的结构</p></li><li><p>关于bigtable的分区策略</p></li><li><p>遇到的单点key热点的问题</p></li></ol><ol><li>单分片一般有多副本，可以让读分流到其他副本上</li><li>本地的二级缓存</li></ol><ol start="5"><li>关于ES的分区问题 ES如何对数据进行分区，其实涉及到倒排索引与正排数据 倒排是否都是全扇出</li></ol>',28);function b(f,_){const i=d("ExternalLinkIcon");return l(),n("div",null,[s,e("p",null,[e("a",c,[a("参考链接"),t(i)]),a(",这就是很好的一个数据系统设计的取舍，对于普通用户，和大V用户的设计分开，毕竟这两个用户的扇出差距巨大。 对于普通用户，会去预生成，因为写入很快，其发表推特之后，可以预先写入其关注者的数据列表中 对于大V用户，这种写入是有问题的，不可能并发去写百万或者千万的关注者的列表， 直接按照关系型数据库的设计去查表即可，但对于这个一定要做好缓存，尽量让查询都命中缓存"),p,a(" 突然想到，其实微信朋友圈的设计就会比较简单了，都是预先生成列表，并且本身也可以针对用户id做数据的分片")]),u])}const S=h(o,[["render",b],["__file","ddia.html.vue"]]);export{S as default};
