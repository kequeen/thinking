import{_ as p,r as e,o,c,a as n,b as s,d as t,e as i}from"./app-47e324c0.js";const l={},u=n("h1",{id:"关于排序",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#关于排序","aria-hidden":"true"},"#"),s(" 关于排序")],-1),r=n("p",null,"日常工作中用到的算法，其实很大一部分都与排序有关。想从自己理解的角度去谈一下排序算法 其实日常工作中需要自己手写排序的地方并不多，基本上所有的编程语言都内置了排序功能，实现上基本用的快速排序，在时间与空间耗费上相对较为均衡的算法。 就算我们对复杂对象进行排序，也只需要我们定义好compare 函数，语言层面就能做好这个事情。 这里从我们日常使用场景下比较常见",-1),k=n("h2",{id:"冒泡排序",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#冒泡排序","aria-hidden":"true"},"#"),s(" 冒泡排序")],-1),d={href:"https://zh.wikipedia.org/zh-sg/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F",target:"_blank",rel:"noopener noreferrer"},v={href:"https://book.douban.com/subject/35641088/",target:"_blank",rel:"noopener noreferrer"},m=i(`<div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token comment">// BubbleSort 冒泡排序. data必须实现sort包中的Interface接口</span>
<span class="token keyword">func</span> <span class="token function">BubbleSort</span><span class="token punctuation">(</span>data sort<span class="token punctuation">.</span>Interface<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	n <span class="token operator">:=</span> data<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
		isChanged <span class="token operator">:=</span> <span class="token boolean">false</span>
		<span class="token keyword">for</span> j <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>i<span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">{</span>
			<span class="token keyword">if</span> data<span class="token punctuation">.</span><span class="token function">Less</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				data<span class="token punctuation">.</span><span class="token function">Swap</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
				isChanged <span class="token operator">=</span> <span class="token boolean">true</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> <span class="token operator">!</span>isChanged <span class="token punctuation">{</span>
			<span class="token keyword">break</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而这个算法上还有一些多余的计算其实很难直接想到，就是相邻数据的比较计算很多都是重复的，因为很多并没有发生交换，每一轮都需要重新比较</p><h2 id="选择排序" tabindex="-1"><a class="header-anchor" href="#选择排序" aria-hidden="true">#</a> 选择排序</h2><p>选择排序与冒泡排序的时空复杂度一样，以前一开始学习的时候，时常分不清楚。 其实与冒泡排序的核心差别就是每一轮只交换一次，会有一个变量记录当前的最大值或者最小值，一轮遍历完成之后，如果目标位置上的值与记录的最大值或者最小值不符，需要进行交换。</p><h2 id="插入排序" tabindex="-1"><a class="header-anchor" href="#插入排序" aria-hidden="true">#</a> 插入排序</h2><p>工业库中在量级小的情况会将其作为快速排序的补充,一般会使用插入排序的升级版--希尔排序，以golang基础库中的代码作为示例</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">Sort</span><span class="token punctuation">(</span>data Interface<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	n <span class="token operator">:=</span> data<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token function">quickSort</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// maxDepth returns a threshold at which quicksort should switch</span>
<span class="token comment">// to heapsort. It returns 2*ceil(lg(n+1)).</span>
<span class="token keyword">func</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> depth <span class="token builtin">int</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> n<span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&gt;&gt;=</span> <span class="token number">1</span> <span class="token punctuation">{</span>
		depth<span class="token operator">++</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> depth <span class="token operator">*</span> <span class="token number">2</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>data Interface<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> maxDepth <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">for</span> b<span class="token operator">-</span>a <span class="token operator">&gt;</span> <span class="token number">12</span> <span class="token punctuation">{</span> <span class="token comment">// Use ShellSort for slices &lt;= 12 elements</span>
		<span class="token keyword">if</span> maxDepth <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
			<span class="token function">heapSort</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
			<span class="token keyword">return</span>
		<span class="token punctuation">}</span>
		maxDepth<span class="token operator">--</span>
		mlo<span class="token punctuation">,</span> mhi <span class="token operator">:=</span> <span class="token function">doPivot</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
		<span class="token comment">// Avoiding recursion on the larger subproblem guarantees</span>
		<span class="token comment">// a stack depth of at most lg(b-a).</span>
		<span class="token keyword">if</span> mlo<span class="token operator">-</span>a <span class="token operator">&lt;</span> b<span class="token operator">-</span>mhi <span class="token punctuation">{</span>
			<span class="token function">quickSort</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> a<span class="token punctuation">,</span> mlo<span class="token punctuation">,</span> maxDepth<span class="token punctuation">)</span>
			a <span class="token operator">=</span> mhi <span class="token comment">// i.e., quickSort(data, mhi, b)</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
			<span class="token function">quickSort</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> mhi<span class="token punctuation">,</span> b<span class="token punctuation">,</span> maxDepth<span class="token punctuation">)</span>
			b <span class="token operator">=</span> mlo <span class="token comment">// i.e., quickSort(data, a, mlo)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> b<span class="token operator">-</span>a <span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token punctuation">{</span>
		<span class="token comment">// Do ShellSort pass with gap 6</span>
		<span class="token comment">// It could be written in this simplified form cause b-a &lt;= 12</span>
		<span class="token keyword">for</span> i <span class="token operator">:=</span> a <span class="token operator">+</span> <span class="token number">6</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> b<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
			<span class="token keyword">if</span> data<span class="token punctuation">.</span><span class="token function">Less</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> i<span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				data<span class="token punctuation">.</span><span class="token function">Swap</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> i<span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">)</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token function">insertionSort</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="堆排序" tabindex="-1"><a class="header-anchor" href="#堆排序" aria-hidden="true">#</a> 堆排序</h2><p>top K问题的常见解法<br> 因为计算机取数据的时候，是按页读与缓存数据的，顺序读数据的话，效率本身要比随机读要高，堆排序需要有效率的随机存取才能变得可行。 核心其实在于新增或者删除节点如何自平衡</p><h2 id="快速排序" tabindex="-1"><a class="header-anchor" href="#快速排序" aria-hidden="true">#</a> 快速排序</h2><p>有时候真的很想感慨，想出快排的人真是个天才。快排也是目前工业界一般情况下选择的算法。毕竟其平均复杂度O(nlogn) 实现方法1，比较容易理解的，但是需要不停创建新的数组</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">var</span> left <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span>
	<span class="token keyword">var</span> right <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span>
	temp <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> temp <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">{</span>
			left <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>
			right <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>right<span class="token punctuation">,</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//分别对左右再进行排序</span>
	left <span class="token operator">=</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span>
	right <span class="token operator">=</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span>
	<span class="token keyword">return</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token function">append</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">,</span> right<span class="token operator">...</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实现方法2，原地排序，就是找到一个中间数，然后递归</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> low<span class="token punctuation">,</span> high <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> low <span class="token operator">&lt;</span> high <span class="token punctuation">{</span>
		<span class="token comment">//寻找切割的下标</span>
		pivotIndex <span class="token operator">:=</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span>
		<span class="token comment">//对左右再分别排序</span>
		<span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> pivotIndex<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> pivotIndex<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

<span class="token punctuation">}</span>

<span class="token comment">// 分区函数</span>
<span class="token keyword">func</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> low <span class="token builtin">int</span><span class="token punctuation">,</span> high <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
	<span class="token comment">//取一个数作为基准</span>
	privot <span class="token operator">:=</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span>
	i <span class="token operator">:=</span> low <span class="token operator">-</span> <span class="token number">1</span>
	<span class="token keyword">for</span> j <span class="token operator">:=</span> low<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> high<span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> privot <span class="token punctuation">{</span>
			i<span class="token operator">++</span>
			arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//交换下位置</span>
	arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span>
	<span class="token keyword">return</span> i <span class="token operator">+</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="归并排序" tabindex="-1"><a class="header-anchor" href="#归并排序" aria-hidden="true">#</a> 归并排序</h2><p>如果只是2个数组的归并排序</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">merge</span><span class="token punctuation">(</span>nums1 <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> m <span class="token builtin">int</span><span class="token punctuation">,</span> nums2 <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">{</span>

	result <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> m<span class="token operator">+</span>n<span class="token punctuation">)</span>
	index <span class="token operator">:=</span> <span class="token number">0</span>
	i<span class="token punctuation">,</span> j <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>
	<span class="token keyword">for</span> i <span class="token operator">&lt;</span> m <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> n <span class="token punctuation">{</span>
		<span class="token keyword">if</span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token punctuation">{</span>
			result<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
			j<span class="token operator">++</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
			result<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
			i<span class="token operator">++</span>
		<span class="token punctuation">}</span>
		index<span class="token operator">++</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> i <span class="token operator">&gt;=</span> m <span class="token punctuation">{</span>
		<span class="token keyword">for</span> j <span class="token operator">&lt;</span> n <span class="token punctuation">{</span>
			result<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
			index<span class="token operator">++</span>
			j<span class="token operator">++</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> j <span class="token operator">&gt;=</span> n <span class="token punctuation">{</span>
		<span class="token keyword">for</span> i <span class="token operator">&lt;</span> m <span class="token punctuation">{</span>
			result<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
			index<span class="token operator">++</span>
			i<span class="token operator">++</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> result
<span class="token punctuation">}</span>


</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果是多个数据的归并排序，就可以用类似于MapReduce的方式来解决</p><h2 id="拓扑排序" tabindex="-1"><a class="header-anchor" href="#拓扑排序" aria-hidden="true">#</a> 拓扑排序</h2>`,19),b={href:"https://juejin.cn/post/6844904033606434823",target:"_blank",rel:"noopener noreferrer"},h=n("h2",{id:"参考文档",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#参考文档","aria-hidden":"true"},"#"),s(" 参考文档")],-1),f={href:"https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95",target:"_blank",rel:"noopener noreferrer"},g={href:"https://zh.m.wikipedia.org/zh/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F",target:"_blank",rel:"noopener noreferrer"},w={href:"https://zh.m.wikipedia.org/zh-hans/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F",target:"_blank",rel:"noopener noreferrer"},_={href:"https://zh.m.wikipedia.org/zh/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F",target:"_blank",rel:"noopener noreferrer"},y={href:"https://zh.m.wikipedia.org/zh/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F",target:"_blank",rel:"noopener noreferrer"};function x(E,j){const a=e("ExternalLinkIcon");return o(),c("div",null,[u,r,k,n("p",null,[n("a",d,[s("冒泡排序"),t(a)]),s("，面试中可能会被问到的其实就是是否还有优化空间了，在吴军老师的"),n("a",v,[s("计算之魂"),t(a)]),s("中其实提到，如何判断算法是否有优化空间，其实就是看算法本身是否有多余的计算。这里最明显的多余的计算，其实就是如果遍历一轮下来，发现其实并没有发生交换，那其实可以说明排序已经提前完成，而我们其实可以算出，其正常循环的话，比较次数为 n(n-1)/2，可以认为其时间复杂度为O(n^2)，空间上理解只用了isChange的标识，数据交换一般也需要一个额外的temp空间，这种都是常数级的空间，所以空间复杂度为 O(1)")]),m,n("p",null,[s("以前在掘金上也写过相关的文章"),n("a",b,[s("https://juejin.cn/post/6844904033606434823"),t(a)]),s(", 有一点比较重要的是，我们该采用邻接链表还是邻接矩阵去表达图，采用不同的数据结构，在解决不同的问题上，难度是有差异的")]),h,n("ol",null,[n("li",null,[n("a",f,[s("https://zh.wikipedia.org/wiki/排序算法"),t(a)])]),n("li",null,[n("a",g,[s("https://zh.m.wikipedia.org/zh/选择排序"),t(a)])]),n("li",null,[n("a",w,[s("https://zh.m.wikipedia.org/zh-hans/插入排序"),t(a)])]),n("li",null,[n("a",_,[s("https://zh.m.wikipedia.org/zh/归并排序"),t(a)])]),n("li",null,[n("a",y,[s("https://zh.m.wikipedia.org/zh/快速排序"),t(a)])])])])}const z=p(l,[["render",x],["__file","sort.html.vue"]]);export{z as default};
