import{_ as o,r as s,o as l,c as i,a as e,b as r,d as n,e as t}from"./app-097a6a1b.js";const h={},d=t(`<h1 id="关于mysql" tabindex="-1"><a class="header-anchor" href="#关于mysql" aria-hidden="true">#</a> 关于mysql</h1><p>mysql可以说是关系型数据库的典型了，大多数互联网公司以及中小公司需要使用关系型数据库的首选。 其本身也是演进的，从 myisam 演进到 innodb 等多种存储引擎 以前的时候，会觉得存储引擎这种词很高大上，但实际上呢，也不过是数据库组织存储数据的方式，我们对数据进行增删改查等各种操作其实都是通过存储引擎。 其实有点类似于我们对文件的变更，其实都是通过操作系统的API去对文件系统（wiki百科的定义，文件系统是一种用于向用户提供底层数据存取的机制）进行操作</p><h2 id="存储引擎" tabindex="-1"><a class="header-anchor" href="#存储引擎" aria-hidden="true">#</a> 存储引擎</h2><p>类似于mysql常用的存储引擎主要有innodb和myisam，一般无特殊要求的情况下，都是使用innodb。 innodb与myisam其中最大的区别就是对于事务的支持，以及对于行锁的支持。</p><h3 id="innodb" tabindex="-1"><a class="header-anchor" href="#innodb" aria-hidden="true">#</a> innodb</h3><p>如何实现事务，其实会依赖于redo log(重做日志)和binlog(归档日志)，其中redo log是innodb存储引擎所特有的日志</p><h2 id="关于索引的选择" tabindex="-1"><a class="header-anchor" href="#关于索引的选择" aria-hidden="true">#</a> 关于索引的选择</h2><p>假设如果a,b,c三个字段都有索引，我们查询条件中</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tableA <span class="token keyword">where</span> a <span class="token operator">=</span> ? <span class="token operator">and</span> b <span class="token operator">=</span> ? <span class="token operator">and</span> c <span class="token operator">=</span> ?  
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,9),p={href:"https://www.51cto.com/article/689113.html",target:"_blank",rel:"noopener noreferrer"},c=e("h2",{id:"存储的数据结构",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#存储的数据结构","aria-hidden":"true"},"#"),r(" 存储的数据结构")],-1),_=e("br",null,null,-1),m={href:"https://en.wikipedia.org/wiki/Skip_list",target:"_blank",rel:"noopener noreferrer"},b={href:"https://en.wikipedia.org/wiki/Log-structured_merge-tree",target:"_blank",rel:"noopener noreferrer"},u={href:"https://segmentfault.com/a/1190000021488885",target:"_blank",rel:"noopener noreferrer"},f=t('<p>其实采用树这种数据结构的根本原因还是在于，磁盘的读取成本很高，而cpu计算很快 MySQL采用B+树作为其主要索引结构，是因为B+树在数据库系统中具有多个优势，使其成为数据库索引的理想选择。以下是MySQL选择B+树作为索引结构的原因：</p><ol><li><p>范围查询效率高：B+树具有良好的范围查询性能。在B+树中，所有叶节点都按照顺序连接，并且范围查询可以通过在树中执行一次遍历来完成，这使得范围查询的效率很高。</p></li><li><p>顺序访问优势：由于B+树中的叶节点按照顺序连接，因此对于顺序访问的操作，例如遍历一个范围内的数据或进行排序，B+树的性能非常出色。</p></li><li><p>内存友好：B+树的内部节点通常比叶节点更小，因为内部节点只包含索引键，而叶节点还包含数据。这种结构使得B+树更适合于在内存中进行操作，减少了磁盘I/O的开销，提高了查询性能。</p></li><li><p>支持聚集索引：在InnoDB存储引擎中，使用B+树实现了聚集索引。聚集索引的叶节点存储了整个数据行，因此可以避免在查询时需要回表查找数据。</p></li><li><p>磁盘空间利用率高：B+树的内部节点不包含数据，而只包含索引键，这使得每个节点可以存储更多的索引项，从而提高了磁盘空间的利用率。</p></li><li><p>插入和删除效率稳定：B+树的插入和删除操作通常比较稳定，不会像B树那样频繁地进行节点的分裂和合并，因此在插入和删除操作频繁的场景下，B+树相对更稳定。</p></li></ol><p>综合上述优点，B+树在大多数情况下是一种高效的索引结构，适用于数据库中需要频繁进行范围查询、排序和顺序访问的情况。因此，MySQL选择了B+树作为其主要索引结构，并且在InnoDB存储引擎中广泛使用B+树来实现聚集索引和辅助索引。</p><h3 id="关于mvcc的数据结构" tabindex="-1"><a class="header-anchor" href="#关于mvcc的数据结构" aria-hidden="true">#</a> 关于mvcc的数据结构</h3><p>这块就需要提到undo log了，用于事务回滚。</p><h2 id="事务" tabindex="-1"><a class="header-anchor" href="#事务" aria-hidden="true">#</a> 事务</h2><p>ACID原则，原子性，一致性，隔离性，持久性 隔离性上，其实又会分四种隔离级别</p><h3 id="读未提交" tabindex="-1"><a class="header-anchor" href="#读未提交" aria-hidden="true">#</a> 读未提交</h3><p>最低的隔离级别，允许一个事务读取其他事务尚未提交的数据 可能导致</p><ol><li>脏读</li><li>不可重复读</li><li>幻读</li></ol><h3 id="读已提交" tabindex="-1"><a class="header-anchor" href="#读已提交" aria-hidden="true">#</a> 读已提交</h3><p>允许一个事务只能读取其他事务已经提交的数据。解决了脏读的问题。 但可能导致：</p><ol><li>不可重复读</li><li>幻读</li></ol><h3 id="可重复读" tabindex="-1"><a class="header-anchor" href="#可重复读" aria-hidden="true">#</a> 可重复读</h3><p>可重复读也不能解决幻读的问题，因为范围查询 解决了不可重复读的问题 还是存在</p><ol><li>幻读</li></ol><h3 id="可串行化" tabindex="-1"><a class="header-anchor" href="#可串行化" aria-hidden="true">#</a> 可串行化</h3><p>最高的隔离级别，要求事务串行执行，完全避免了脏读、不可重复读、幻读的问题，但并发下降了。</p><h2 id="关于mysql的高可用方案" tabindex="-1"><a class="header-anchor" href="#关于mysql的高可用方案" aria-hidden="true">#</a> 关于mysql的高可用方案</h2>',19),k={href:"https://zhuanlan.zhihu.com/p/25960208",target:"_blank",rel:"noopener noreferrer"},B=e("h2",{id:"mysql的横向扩展",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#mysql的横向扩展","aria-hidden":"true"},"#"),r(" mysql的横向扩展")],-1),g={href:"https://dev.mysql.com/doc/refman/8.0/en/group-replication.html",target:"_blank",rel:"noopener noreferrer"},y=e("br",null,null,-1),q=e("br",null,null,-1),x={href:"https://dl.acm.org/doi/pdf/10.1145/2491245",target:"_blank",rel:"noopener noreferrer"},E={href:"https://docs.pingcap.com/zh/tidb/stable/optimistic-transaction%5D",target:"_blank",rel:"noopener noreferrer"},v=e("h2",{id:"参考文档",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#参考文档","aria-hidden":"true"},"#"),r(" 参考文档")],-1),w={href:"https://dev.mysql.com/doc/",target:"_blank",rel:"noopener noreferrer"},z={href:"https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/8969956",target:"_blank",rel:"noopener noreferrer"},A={href:"https://baike.baidu.com/item/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/8999831",target:"_blank",rel:"noopener noreferrer"},D={href:"https://zh.m.wikipedia.org/zh-hans/%E4%BA%8B%E5%8B%99%E9%9A%94%E9%9B%A2",target:"_blank",rel:"noopener noreferrer"},I={href:"https://draveness.me/whys-the-design-mysql-b-plus-tree/",target:"_blank",rel:"noopener noreferrer"},L={href:"https://zh.m.wikipedia.org/zh-hans/B%2B%E6%A0%91",target:"_blank",rel:"noopener noreferrer"},S={href:"https://redisbook.readthedocs.io/en/latest/internal-datastruct/skiplist.html",target:"_blank",rel:"noopener noreferrer"},M={href:"https://dev.mysql.com/doc/refman/8.0/en/group-replication.html",target:"_blank",rel:"noopener noreferrer"};function N(V,C){const a=s("ExternalLinkIcon");return l(),i("div",null,[d,e("p",null,[r("该如何选择索引，具体可参考"),e("a",p,[r("这篇文章"),n(a)]),r(",会选择索引基数较大的字段")]),c,e("p",null,[r("关系型数据库一般是按行组织数据。 例如mysql中的innoDB存储引擎采用B+树作为存储，pgsql中使用B树。"),_,r(" 今天的各种存储引擎也有用"),e("a",m,[r("跳表"),n(a)]),r("（以redis为例）和"),e("a",b,[r("LSM树"),n(a)]),r("(以rocksdb为例)")]),e("p",null,[r("B树与B+树之间的区别是，数据是否会存储在叶子节点 相关的详细比较可以参考"),e("a",u,[r("这篇文章"),n(a)])]),f,e("p",null,[r("具体可参考"),e("a",k,[r("这篇文章"),n(a)]),r("，其实核心还是那几种方案，主从，双主，多副本")]),B,e("p",null,[r("可以直接关注横向扩展方案。目前官方是使用"),e("a",g,[r("Group Replication"),n(a)]),r("的方案"),y,r(" 节点新增或减少对数据的迁移，以及如何对事务的支持"),q,r(" Google的"),e("a",x,[r("spanner论文"),n(a)]),r("其实是一个很好的解决方案 看下 TIDB 中是如何对分布式事务进行支持的，可看"),e("a",E,[r("这篇文档"),n(a)])]),v,e("ol",null,[e("li",null,[e("a",w,[r("https://dev.mysql.com/doc/"),n(a)])]),e("li",null,[e("a",z,[r("https://baike.baidu.com/item/存储引擎/8969956"),n(a)])]),e("li",null,[e("a",A,[r("https://baike.baidu.com/item/关系型数据库/8999831"),n(a)])]),e("li",null,[e("a",D,[r("https://zh.m.wikipedia.org/zh-hans/事務隔離"),n(a)])]),e("li",null,[e("a",I,[r("https://draveness.me/whys-the-design-mysql-b-plus-tree/"),n(a)])]),e("li",null,[e("a",L,[r("https://zh.m.wikipedia.org/zh-hans/B%2B树"),n(a)])]),e("li",null,[e("a",S,[r("https://redisbook.readthedocs.io/en/latest/internal-datastruct/skiplist.html"),n(a)])]),e("li",null,[e("a",M,[r("https://dev.mysql.com/doc/refman/8.0/en/group-replication.html"),n(a)])])])])}const G=o(h,[["render",N],["__file","mysql.html.vue"]]);export{G as default};
