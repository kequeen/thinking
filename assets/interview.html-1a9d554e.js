import{_ as o,r as l,o as p,c as i,a as n,b as s,d as e,e as t}from"./app-097a6a1b.js";const c={},r=n("h1",{id:"一些常见问题",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#一些常见问题","aria-hidden":"true"},"#"),s(" 一些常见问题")],-1),d=n("p",null,"整理常被问到的细节问题，像类似于并发、GC、GMP等，就单独开文章去写，其它的部分就更新在这里。",-1),u=n("h2",{id:"如何理解协程",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#如何理解协程","aria-hidden":"true"},"#"),s(" 如何理解协程")],-1),k=n("br",null,null,-1),h={href:"https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B",target:"_blank",rel:"noopener noreferrer"},m=n("p",null,"其实又会延伸另外一个问题，多线程场景下，单个线程的崩溃是否可能引起其它线程的崩溃？",-1),v=n("h2",{id:"关于golang中的逃逸分析",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#关于golang中的逃逸分析","aria-hidden":"true"},"#"),s(" 关于golang中的逃逸分析")],-1),b={href:"https://en.wikipedia.org/wiki/Escape_analysis",target:"_blank",rel:"noopener noreferrer"},g=n("blockquote",null,[n("p",null,"如果函数外部没有引用，则优先放到栈中； 如果函数外部存在引用，则必定放到堆中； 也会有一些异常情况：")],-1),_=n("ol",null,[n("li",null,"interface{} 动态类型逃逸"),n("li",null,"栈空间大小不足")],-1),f=n("p",null,"更多细节可以参考着两篇文章：",-1),w={href:"https://geektutu.com/post/hpg-escape-analysis.html",target:"_blank",rel:"noopener noreferrer"},x={href:"https://golang.design/go-questions/compile/escape/",target:"_blank",rel:"noopener noreferrer"},y=n("h2",{id:"slice和map的底层原理",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#slice和map的底层原理","aria-hidden":"true"},"#"),s(" slice和map的底层原理")],-1),E={href:"https://golang.design/go-questions/slice/vs-array/",target:"_blank",rel:"noopener noreferrer"},B=t(`<div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">type</span> slice <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	array unsafe<span class="token punctuation">.</span>Pointer <span class="token comment">// 元素指针</span>
	<span class="token builtin">len</span>   <span class="token builtin">int</span> <span class="token comment">// 长度 </span>
	<span class="token builtin">cap</span>   <span class="token builtin">int</span> <span class="token comment">// 容量</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="如何优雅退出协程" tabindex="-1"><a class="header-anchor" href="#如何优雅退出协程" aria-hidden="true">#</a> 如何优雅退出协程</h2><h2 id="golang中切片的扩展规则" tabindex="-1"><a class="header-anchor" href="#golang中切片的扩展规则" aria-hidden="true">#</a> Golang中切片的扩展规则</h2>`,3),q={href:"https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/",target:"_blank",rel:"noopener noreferrer"},G=t(`<div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code>	newcap <span class="token operator">:=</span> old<span class="token punctuation">.</span><span class="token builtin">cap</span>
	doublecap <span class="token operator">:=</span> newcap <span class="token operator">+</span> newcap
	<span class="token keyword">if</span> <span class="token builtin">cap</span> <span class="token operator">&gt;</span> doublecap <span class="token punctuation">{</span>
		newcap <span class="token operator">=</span> <span class="token builtin">cap</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
		<span class="token keyword">const</span> threshold <span class="token operator">=</span> <span class="token number">256</span>
		<span class="token keyword">if</span> old<span class="token punctuation">.</span><span class="token builtin">cap</span> <span class="token operator">&lt;</span> threshold <span class="token punctuation">{</span>
			newcap <span class="token operator">=</span> doublecap
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
			<span class="token comment">// Check 0 &lt; newcap to detect overflow</span>
			<span class="token comment">// and prevent an infinite loop.</span>
			<span class="token keyword">for</span> <span class="token number">0</span> <span class="token operator">&lt;</span> newcap <span class="token operator">&amp;&amp;</span> newcap <span class="token operator">&lt;</span> <span class="token builtin">cap</span> <span class="token punctuation">{</span>
				<span class="token comment">// Transition from growing 2x for small slices</span>
				<span class="token comment">// to growing 1.25x for large slices. This formula</span>
				<span class="token comment">// gives a smooth-ish transition between the two.</span>
				newcap <span class="token operator">+=</span> <span class="token punctuation">(</span>newcap <span class="token operator">+</span> <span class="token number">3</span><span class="token operator">*</span>threshold<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">4</span>
			<span class="token punctuation">}</span>
			<span class="token comment">// Set newcap to the requested cap when</span>
			<span class="token comment">// the newcap calculation overflowed.</span>
			<span class="token keyword">if</span> newcap <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
				newcap <span class="token operator">=</span> <span class="token builtin">cap</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>扩容的规则显而易见，新的cap的计算分为以下几种情况：<br> 1）如果没有达到当前分配的容量，其实就不需要扩容，cap不变<br> 2）newcap超过oldcap的2倍的话，直接扩容到新的cap<br> 3）新的cap未超过旧的cap的2倍，但小于256，则直接newcap<br> 4）如果已经超过256，则每次扩容1.25倍</p><h2 id="由第一个问题可以引申出第二个问题-golang中的map的扩容" tabindex="-1"><a class="header-anchor" href="#由第一个问题可以引申出第二个问题-golang中的map的扩容" aria-hidden="true">#</a> 由第一个问题可以引申出第二个问题，golang中的map的扩容</h2>`,3),j={href:"https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/",target:"_blank",rel:"noopener noreferrer"},A=t(`<h2 id="golang中json解析相关的问题" tabindex="-1"><a class="header-anchor" href="#golang中json解析相关的问题" aria-hidden="true">#</a> Golang中json解析相关的问题</h2><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code>	<span class="token comment">//测试下切片相关的操作</span>
	<span class="token keyword">var</span> a <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span>
	<span class="token keyword">if</span> a <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;a is nil&quot;</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	b <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> b <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;b is nil&quot;</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//output</span>
	<span class="token comment">// a is nil</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个是类型初始化方式的不同，golang中是否会分配默认值，或者是实际占用内存，类似于用var这种方式定义切片，其实本身是没有实际分配内存的 会导致json解析的结果不同</p><h2 id="关于反射的使用场景" tabindex="-1"><a class="header-anchor" href="#关于反射的使用场景" aria-hidden="true">#</a> 关于反射的使用场景</h2>`,4),P={href:"https://mp.weixin.qq.com/s/298AO5no7MUlDGGGK9aPeQ",target:"_blank",rel:"noopener noreferrer"},C=n("br",null,null,-1),N=n("h2",{id:"关于字符串的遍历",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#关于字符串的遍历","aria-hidden":"true"},"#"),s(" 关于字符串的遍历")],-1),V={href:"https://berryjam.github.io/2018/03/%E4%BB%8Egolang%E5%AD%97%E7%AC%A6%E4%B8%B2string%E9%81%8D%E5%8E%86%E8%AF%B4%E8%B5%B7/",target:"_blank",rel:"noopener noreferrer"};function D(M,T){const a=l("ExternalLinkIcon");return p(),i("div",null,[r,d,u,n("p",null,[s("首先我们要从操作系统的进程说起，虽然linux本身已经让进程创建的成本很低了，但实际上进程的创建的开销对于操作系统而言还是太大。"),k,s(" 为此，又有了"),n("a",h,[s("线程"),e(a)]),s("，线程是操作系统向其分配处理器的最小单元。同一进程下的多线程本身享有进程中的全部系统资源，但每个线程本身，还是有自己的调用栈，寄存器。协程的本质其实就是用户态线程。")]),m,v,n("p",null,[n("a",b,[s("逃逸分析"),e(a)]),s(",其实就是确认在哪里可以访问到指针，核心目的是将内存分配到堆上或者分配到栈上。 逃逸分析的基本原则")]),g,_,f,n("ol",null,[n("li",null,[n("a",w,[s("Go逃逸分析"),e(a)])]),n("li",null,[n("a",x,[s("逃逸分析是怎么进行的"),e(a)])])]),y,n("p",null,[s("可参考"),n("a",E,[s("这篇文档"),e(a)]),s(" 核心是理解其底层结构")]),B,n("p",null,[s("其实可以理解为切片如何做自动扩容 可以参考"),n("a",q,[s("这篇文章"),e(a)]),s(",以及golang中的源码")]),G,n("p",null,[s("这块可以参考"),n("a",j,[s("这篇文章"),e(a)])]),A,n("p",null,[s("我理解其实线上服务应该尽可能的少用反射，因为反射本身是有性能损耗的，但一些场景来说，其实反射也是不可或缺的 关于反射的原理，可以参考"),n("a",P,[s("这篇文章"),e(a)]),C,s(" 网上的示例使用场景是用于类似于ORM框架这种，将对象本身转化成sql。其实golang源码中的json包也用了反射，将json反序列化到对象上")]),N,n("p",null,[n("a",V,[s("相关链接"),e(a)]),s(",自己之前也一直模糊的点在于如何遍历字符串，这个文章里面就说得比较清楚，range是用字符遍历，s[i]这种方式是用字节去遍历，就是所谓的rune类型，也是int32的别名")])])}const I=o(c,[["render",D],["__file","interview.html.vue"]]);export{I as default};
