import{_ as a,o as n,c as e,e as s}from"./app-47e324c0.js";const t={},i=s(`<h1 id="关于gc" tabindex="-1"><a class="header-anchor" href="#关于gc" aria-hidden="true">#</a> 关于GC</h1><p>基本上所有现代的语言都会包含GC，毕竟让用户去手动管理内存，大多数用户其实并不具备这样的知识能力。并且其实最好的抽象，其实就是让上游的用户能更聚焦在其业务逻辑上，而不用为这些底层问题去操心。</p><p>我们应该以什么样的思路去理解GC？分配在栈上或者是分配在堆上，各种情况是如何取舍的？</p><h2 id="设计原理" tabindex="-1"><a class="header-anchor" href="#设计原理" aria-hidden="true">#</a> 设计原理</h2><p>一般分为3个组件，就是用户程序、分配器和收集器</p><h3 id="分配方法" tabindex="-1"><a class="header-anchor" href="#分配方法" aria-hidden="true">#</a> 分配方法</h3><ol><li>线性分配器 缺点： 线性分配器无法在内存被释放时重用内存</li><li>空闲链表分配器 golang中采用的方式 隔离适应（Segregated-Fit）— 将内存分割成多个链表，每个链表中的内存块大小相同，申请内存时先找到满足条件的链表，再从链表中选择合适的内存块</li></ol><p>线程分配缓存(TCMalloc)是用于分配内存的机制</p><p>对象分类：</p><ol><li>微对象</li><li>小对象</li><li>大对象</li></ol><p>线程缓存、中心缓存和页堆</p><h2 id="代码分析" tabindex="-1"><a class="header-anchor" href="#代码分析" aria-hidden="true">#</a> 代码分析</h2><h3 id="片段1" tabindex="-1"><a class="header-anchor" href="#片段1" aria-hidden="true">#</a> 片段1</h3><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code>	slice <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> <span class="token punctuation">{</span>
		slice <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>slice<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这一段其实是会导致out of memory， 切片（slice）是分配在堆上的，它包含了一个指向底层数组的指针，长度和容量。 数组（array）是分配在栈上的，它是一个固定大小的值类型。 oom不被认为是panic，panic可以看做是Go中的一种内建异常。</p><h2 id="一些问题" tabindex="-1"><a class="header-anchor" href="#一些问题" aria-hidden="true">#</a> 一些问题</h2><ol><li>如何减少GC所需的时间 如何减少延时，避免STW，其实也是GC算法一直需要care的点 如何对线上服务做GC监控，我理解是不论对于java或者golang，其实都很难对线上服务直接监控，还是只能去做更为全局的监控</li></ol><h2 id="参考文档" tabindex="-1"><a class="header-anchor" href="#参考文档" aria-hidden="true">#</a> 参考文档</h2><p>https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/</p>`,19),o=[i];function c(l,p){return n(),e("div",null,o)}const d=a(t,[["render",c],["__file","gc.html.vue"]]);export{d as default};
