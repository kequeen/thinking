import{_ as e,o as a,c as t,e as r}from"./app-47e324c0.js";const s={},c=r('<h1 id="秒杀系统设计" tabindex="-1"><a class="header-anchor" href="#秒杀系统设计" aria-hidden="true">#</a> 秒杀系统设计</h1><p>这个也是经常会被考察的一个问题 其实这个问题主要有两方面，一个是前置阶段的限流设计，一个是限流之后的事务设计 当然，在这个问题之前，其实应该考虑的是系统的设计目标，比如QPS，以及延时等相关指标</p><h2 id="限流设计" tabindex="-1"><a class="header-anchor" href="#限流设计" aria-hidden="true">#</a> 限流设计</h2><h2 id="事务设计" tabindex="-1"><a class="header-anchor" href="#事务设计" aria-hidden="true">#</a> 事务设计</h2><p>所有请求直接涌入数据库其实也会对数据库IO造成冲击，因为事务本身是很重的。前置可以采用分布式锁，去判断能否去获取数据库IO</p>',5),h=[c];function d(i,n){return a(),t("div",null,h)}const _=e(s,[["render",d],["__file","spike_system.html.vue"]]);export{_ as default};
